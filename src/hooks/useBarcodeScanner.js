import { useEffect, useRef, useCallback, useState, useMemo } from 'react';
import { DEFAULT_SCANNER_OPTIONS, BARCODE_PATTERNS, SCANNER_STATUS } from '../config/barcodeConfig';

/**
 * Custom hook for barcode scanning functionality
 * Listens for rapid keyboard input typically generated by barcode scanners
 * 
 * @param {Object} options - Configuration options
 * @param {Function} options.onScan - Callback function when barcode is scanned
 * @param {boolean} options.enabled - Whether scanner is enabled
 * @param {Array<string>} options.endKeys - Keys that signal end of barcode
 * @param {number} options.minLength - Minimum barcode length
 * @param {number} options.scanTimeoutMs - Timeout between keystrokes
 * @param {boolean} options.allowInInputs - Allow scanning in input fields
 * @param {string} options.prefix - Prefix to remove from barcode
 * @param {string} options.suffix - Suffix to remove from barcode
 * @param {Function} options.onStatusChange - Callback for status changes
 * @param {Function} options.onError - Callback for errors
 * @returns {Object} - Scanner status and control functions
 */
export const useBarcodeScanner = (options = {}) => {
  const config = useMemo(() => ({ ...DEFAULT_SCANNER_OPTIONS, ...options }), [options]);
  
  // Refs for managing scanner state
  const bufferRef = useRef('');
  const timeoutRef = useRef(null);
  const isActiveRef = useRef(false);
  
  // State for tracking scanner status
  const [status, setStatus] = useState(
    config.enabled ? SCANNER_STATUS.IDLE : SCANNER_STATUS.DISABLED
  );
  const [lastScannedCode, setLastScannedCode] = useState(null);
  const [scanCount, setScanCount] = useState(0);

  /**
   * Update scanner status and notify listeners
   */
  const updateStatus = useCallback((newStatus) => {
    setStatus(newStatus);
    if (config.onStatusChange) {
      config.onStatusChange(newStatus);
    }
  }, [config]);

  /**
   * Check if the current focused element is an input field
   */
  const isInputElement = useCallback((element) => {
    if (!element) return false;
    
    const inputTypes = ['INPUT', 'TEXTAREA', 'SELECT'];
    const isContentEditable = element.contentEditable === 'true';
    const isInputField = inputTypes.includes(element.tagName);
    
    return isInputField || isContentEditable;
  }, []);

  /**
   * Normalize barcode by removing prefix/suffix and trimming
   */
  const normalizeBarcode = useCallback((code) => {
    let normalized = code.trim();
    
    // Remove prefix if configured
    if (config.prefix && normalized.startsWith(config.prefix)) {
      normalized = normalized.substring(config.prefix.length);
    }
    
    // Remove suffix if configured
    if (config.suffix && normalized.endsWith(config.suffix)) {
      normalized = normalized.substring(0, normalized.length - config.suffix.length);
    }
    
    return normalized.trim();
  }, [config.prefix, config.suffix]);

  /**
   * Validate barcode format (basic validation)
   */
  const validateBarcode = useCallback((code) => {
    if (!code || code.length < config.minLength) {
      return false;
    }
    
    // Check against common patterns (at least one should match)
    const patterns = Object.values(BARCODE_PATTERNS);
    return patterns.some(pattern => pattern.test(code));
  }, [config.minLength]);

  /**
   * Process the scanned barcode
   */
  const processBarcode = useCallback((rawCode) => {
    try {
      updateStatus(SCANNER_STATUS.PROCESSING);
      
      const normalizedCode = normalizeBarcode(rawCode);
      
      if (!validateBarcode(normalizedCode)) {
        const error = `Invalid barcode format: ${normalizedCode}`;
        console.warn('Barcode Scanner:', error);
        
        if (config.onError) {
          config.onError(new Error(error));
        }
        
        updateStatus(SCANNER_STATUS.ERROR);
        setTimeout(() => updateStatus(SCANNER_STATUS.IDLE), 1000);
        return;
      }
      
      // Update scan statistics
      setLastScannedCode(normalizedCode);
      setScanCount(prev => prev + 1);
      
      // Call the scan handler
      if (config.onScan) {
        config.onScan(normalizedCode);
      }
      
      updateStatus(SCANNER_STATUS.IDLE);
      
    } catch (error) {
      console.error('Barcode Scanner: Error processing barcode:', error);
      
      if (config.onError) {
        config.onError(error);
      }
      
      updateStatus(SCANNER_STATUS.ERROR);
      setTimeout(() => updateStatus(SCANNER_STATUS.IDLE), 1000);
    }
  }, [normalizeBarcode, validateBarcode, config, updateStatus]);

  /**
   * Clear the scanning buffer
   */
  const clearBuffer = useCallback(() => {
    bufferRef.current = '';
    isActiveRef.current = false;
    
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
    
    if (status === SCANNER_STATUS.SCANNING) {
      updateStatus(SCANNER_STATUS.IDLE);
    }
  }, [status, updateStatus]);

  /**
   * Handle keydown events for barcode scanning
   */
  const handleKeyDown = useCallback((event) => {
    // Skip if scanner is disabled
    if (!config.enabled || status === SCANNER_STATUS.DISABLED) {
      return;
    }
    
    // Skip if focused on input field and not allowed
    if (!config.allowInInputs && isInputElement(event.target)) {
      return;
    }
    
    // Handle end keys (Enter, Tab, etc.)
    if (config.endKeys.includes(event.code) || config.endKeys.includes(event.key)) {
      if (bufferRef.current.length >= config.minLength) {
        event.preventDefault(); // Prevent default behavior for barcode input
        processBarcode(bufferRef.current);
      }
      clearBuffer();
      return;
    }
    
    // Handle character input
    if (event.key.length === 1) {
      // Start scanning mode if not already active
      if (!isActiveRef.current) {
        isActiveRef.current = true;
        updateStatus(SCANNER_STATUS.SCANNING);
      }
      
      // Add character to buffer
      bufferRef.current += event.key;
      
      // Prevent default if this looks like scanner input (rapid typing)
      if (isActiveRef.current && bufferRef.current.length > 2) {
        event.preventDefault();
      }
      
      // Reset timeout
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
      
      timeoutRef.current = setTimeout(() => {
        clearBuffer();
      }, config.scanTimeoutMs);
    }
  }, [
    config, 
    status, 
    isInputElement, 
    processBarcode, 
    clearBuffer, 
    updateStatus
  ]);

  /**
   * Enable or disable the scanner
   */
  const setEnabled = useCallback((enabled) => {
    updateStatus(enabled ? SCANNER_STATUS.IDLE : SCANNER_STATUS.DISABLED);
    clearBuffer();
  }, [updateStatus, clearBuffer]);

  /**
   * Manually simulate a barcode scan (for testing)
   */
  const simulateScan = useCallback((barcode) => {
    if (status === SCANNER_STATUS.DISABLED) {
      console.warn('Barcode Scanner: Cannot simulate scan - scanner is disabled');
      return;
    }
    
    processBarcode(barcode);
  }, [status, processBarcode]);

  /**
   * Get current scanner statistics
   */
  const getStats = useCallback(() => {
    return {
      status,
      scanCount,
      lastScannedCode,
      bufferLength: bufferRef.current.length,
      isActive: isActiveRef.current
    };
  }, [status, scanCount, lastScannedCode]);

  // Setup global event listener
  useEffect(() => {
    if (config.enabled) {
      document.addEventListener('keydown', handleKeyDown, true);
      
      return () => {
        document.removeEventListener('keydown', handleKeyDown, true);
        clearBuffer();
      };
    }
  }, [handleKeyDown, clearBuffer, config.enabled]);

  // Update status when enabled prop changes
  useEffect(() => {
    setEnabled(config.enabled);
  }, [config.enabled, setEnabled]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      clearBuffer();
    };
  }, [clearBuffer]);

  return {
    // Status information
    status,
    scanCount,
    lastScannedCode,
    
    // Control functions
    setEnabled,
    simulateScan,
    clearBuffer,
    getStats,
    
    // Configuration (read-only)
    config: { ...config }
  };
};

export default useBarcodeScanner;